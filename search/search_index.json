{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview About Steel Core Steel is a 3-stage single-issue in-order RISC-V microprocessor core designed to be simple and easy to use. It is intended for use in FPGAs as the processing unit in embedded systems projects. Key features: Easy to use Targeted for use in FPGAs Implements the RV32I base instruction set + Zicsr extension M-mode privilege level support Hardware described in Verilog 3 pipeline stages Single-issue Fully documented Passed all RV32IZicsr tests from RISC-V test and compliance suites 0.46 CoreMarks / MHz Licensing Steel is distributed under the MIT License . The license text is reproduced in the LICENCE.md file. Read it carefully and make sure you understand its terms before using Steel in your own projects. Specifications version Steel aims to be compliant with the following RISC-V specifications: Base ISA RV32I version 2.1 Zicsr extension version 2.0 Machine ISA version 1.11 Online repository Steel files and documentation are available at GitHub ( github.com/rafaelcalcada/steel-core ).","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#about-steel-core","text":"Steel is a 3-stage single-issue in-order RISC-V microprocessor core designed to be simple and easy to use. It is intended for use in FPGAs as the processing unit in embedded systems projects. Key features: Easy to use Targeted for use in FPGAs Implements the RV32I base instruction set + Zicsr extension M-mode privilege level support Hardware described in Verilog 3 pipeline stages Single-issue Fully documented Passed all RV32IZicsr tests from RISC-V test and compliance suites 0.46 CoreMarks / MHz","title":"About Steel Core"},{"location":"#licensing","text":"Steel is distributed under the MIT License . The license text is reproduced in the LICENCE.md file. Read it carefully and make sure you understand its terms before using Steel in your own projects.","title":"Licensing"},{"location":"#specifications-version","text":"Steel aims to be compliant with the following RISC-V specifications: Base ISA RV32I version 2.1 Zicsr extension version 2.0 Machine ISA version 1.11","title":"Specifications version"},{"location":"#online-repository","text":"Steel files and documentation are available at GitHub ( github.com/rafaelcalcada/steel-core ).","title":"Online repository"},{"location":"config/","text":"Configuration Steel configuration parameters can be modified by editing the globals.vh file (located inside the rtl directory). The following subsections describe the parameters that can be changed and its default values. Boot address The BOOT_ADDRESS parameter sets the memory position of the first instruction the core will fetch after reset. It can be changed to any 32-bit value. Its default value is 0x00000000 . CSRs reset values The reset value of some control and status records (CSRs) can be modified. The table below shows these CSRs and accepted values. The default value for all of them is zero . Parameter name Description MCYCLE_RESET Value of the mcycle CSR after reset. It can be changed to any 32-bit value. MCYCLEH_RESET Value of the mcycleh CSR after reset. It can be changed to any 32-bit value. TIME_RESET Value of the time CSR after reset. It can be changed to any 32-bit value. TIMEH_RESET Value of the timeh CSR after reset. It can be changed to any 32-bit value. MINSTRET_RESET Value of the minstret CSR after reset. It can be changed to any 32-bit value. MINSTRETH_RESET Value of the minstreth CSR after reset. It can be changed to any 32-bit value. MTVEC_BASE_RESET Value of the base field of mtvec CSR after reset. The value is used in the trap handler address calculation. It can be changed to any 30-bit value. MTVEC_MODE_RESET Value of the mode field of mtvec CSR after reset. It defines the interrupt mode and can be changed to the value 00 (direct mode) or 01 (vectored mode). MSCRATCH_RESET Value of the mscratch CSR after reset. It can be changed to any 32-bit value. MEPC_RESET Value of the mepc CSR after reset. It can be changed to any 32-bit address aligned on a four byte boundary (the last two bits must be set to zero). MCOUNTINHIBIT_CY_RESET Enables or inhibits cycle counting (1 inhibits, 0 enables). MCOUNTINHIBIT_IR_RESET Enables or inhibits instructions retired counting (1 inhibits, 0 enables).","title":"Configuration"},{"location":"config/#configuration","text":"Steel configuration parameters can be modified by editing the globals.vh file (located inside the rtl directory). The following subsections describe the parameters that can be changed and its default values.","title":"Configuration"},{"location":"config/#boot-address","text":"The BOOT_ADDRESS parameter sets the memory position of the first instruction the core will fetch after reset. It can be changed to any 32-bit value. Its default value is 0x00000000 .","title":"Boot address"},{"location":"config/#csrs-reset-values","text":"The reset value of some control and status records (CSRs) can be modified. The table below shows these CSRs and accepted values. The default value for all of them is zero . Parameter name Description MCYCLE_RESET Value of the mcycle CSR after reset. It can be changed to any 32-bit value. MCYCLEH_RESET Value of the mcycleh CSR after reset. It can be changed to any 32-bit value. TIME_RESET Value of the time CSR after reset. It can be changed to any 32-bit value. TIMEH_RESET Value of the timeh CSR after reset. It can be changed to any 32-bit value. MINSTRET_RESET Value of the minstret CSR after reset. It can be changed to any 32-bit value. MINSTRETH_RESET Value of the minstreth CSR after reset. It can be changed to any 32-bit value. MTVEC_BASE_RESET Value of the base field of mtvec CSR after reset. The value is used in the trap handler address calculation. It can be changed to any 30-bit value. MTVEC_MODE_RESET Value of the mode field of mtvec CSR after reset. It defines the interrupt mode and can be changed to the value 00 (direct mode) or 01 (vectored mode). MSCRATCH_RESET Value of the mscratch CSR after reset. It can be changed to any 32-bit value. MEPC_RESET Value of the mepc CSR after reset. It can be changed to any 32-bit address aligned on a four byte boundary (the last two bits must be set to zero). MCOUNTINHIBIT_CY_RESET Enables or inhibits cycle counting (1 inhibits, 0 enables). MCOUNTINHIBIT_IR_RESET Enables or inhibits instructions retired counting (1 inhibits, 0 enables).","title":"CSRs reset values"},{"location":"details/","text":"Implementation Details This section contains information on implementation details. It is intended for those who want to know more about how Steel works. Implemented CSRs The control and status registers implemented in Steel are shown in table 1, below. The required M-mode registers not shown in the table return the hardwired value predicted by the specifications when read. Table 1. Implemented CSRs CSR Name Address cycle Cycle Counter 0xC00 time System Timer 0xC01 instret Instructions Retired 0xC02 mstatus Machine Status 0x300 misa Machine ISA 0x301 mie Machine Interrupt Enable 0x304 mtvec Machine Trap Vector 0x305 mscratch Machine Scratch 0x340 mepc Machine Exception Program Counter 0x341 mcause Machine Cause 0x342 mtval Machine Trap Value 0x343 mip Machine Interrupt Pending 0x344 mcycle Machine Cycle Counter 0xB00 minstret Machine Instructions Retired 0xB01 mcountinhibit Machine Counter Inhibit 0x320 Modules Decoder The Decoder ( decoder.v ) decodes the instruction and generates the signals that control the memory, the Load Unit, the Store Unit, the ALU, the two register files (Integer and CSR), the Immediate Generator and the Writeback Multiplexer. The description of its input and output signals are shown in table 2, below. Table 2. Decoder input/output signals Signal name Width Direction Description OPCODE_6_TO_2 5 bits Input Connected to the instruction opcode field. FUNCT7_5 1 bit Input Connected to the instruction funct7 field. FUNCT3 3 bits Input Connected to the instruction funct3 field. IADDER_OUT_1_TO_0 2 bits Input Used to verify the alignment of loads and stores. TRAP_TAKEN 1 bit Input When set high indicates that a trap will be taken in the next clock cycle. Connected to the Machine Control module. ALU_OPCODE 4 bits Output Selects the operation to be performed by the ALU. MEM_WR_REQ 1 bit Output When set high indicates a request to write to memory. LOAD_SIZE 2 bits Output Indicates the word size of load instruction. LOAD_UNSIGNED 1 bit Output Indicates the type of load instruction (signed or unsigned). ALU_SRC 1 bit Output Selects the ALU 2nd operand. IADDER_SRC 1 bit Output Selects the Immediate Adder 2nd operand. CSR_WR_EN 1 bit Output Controls the WR_EN input of CSR Register File. RF_WR_EN 1 Output Controls the WR_EN input of Integer Register File. WB_MUX_SEL 3 Output Selects the data to be written in the Integer Register File. IMM_TYPE 3 Output Selects the immediate based on the type of the instruction. CSR_OP 3 Output Selects the operation to be performed by the CSR Register File (read/write, set or clear). ILLEGAL_INSTR 1 bit Output When set high indicates that an invalid or not implemented instruction was fetched from memory. MISALIGNED_LOAD 1 bit Output When set high indicates an attempt to read data in disagreement with the memory alignment rules. MISALIGNED_STORE 1 bit Output When set high indicates an attempt to write data to memory in disagreement with the memory alignment rules. ALU The ALU ( alu.v ) applies ten distinct logical and arithmetic operations in parallel to two 32-bit operands, outputting the result selected by OPCODE . The ALU input/output signals and the opcodes are shown in tables 3 and 4, below. The opcode values were assigned to facilitate instruction translation. The most significant bit of OPCODE matches with the second most significant bit in the instruction funct7 field. The remaining three bits match with the instruction funct3 field. Table 3. ALU input/output signals Signal name Width Direction Description OP_1 32 bits Input Operation first operand. OP_2 32 bits Input Operation second operand. OPCODE 4 bits Input Operation code. This signal is driven by funct7 and funct3 instruction fields. RESULT 32 bits Output Result of the requested operation. Table 4. ALU opcodes Opcode Operation Binary value ALU_ADD Addition 4'b0000 ALU_SUB Subtraction 4'b1000 ALU_SLT Set on less than 4'b0010 ALU_SLTU Set on less than unsigned 4'b0011 ALU_AND Bitwise logical AND 4'b0111 ALU_OR Bitwise logical OR 4'b0110 ALU_XOR Bitwise logical XOR 4'b0100 ALU_SLL Logical left shift 4'b0001 ALU_SRL Logical right shift 4'b0101 ALU_SRA Arithmetic right shift 4'b1101 Integer Register File The Integer Register File ( integer_file.v ) has 32 general-purpose registers and supports read and write operations. Reads are requested in the pipeline stage 2 and provide data from one or two registers. Writes are requested in the pipeline stage 3 and put the data coming from the Writeback Multiplexer into the selected register. If stage 3 requests to write to a register being read by stage 2, the data to be written is immediately forwarded to stage 2. Each operation is driven by a distinct set of signals, shown in the tables 5 and 6, below. Table 5. Integer Register File signals for read Signal name Width Direction Description RS_1_ADDR 5 bits Input Register source 1 address . The data is placed at RS_1 immediately after an address change. RS_2_ADDR 5 bits Input Register source 2 address . The data is placed at RS_2 immediately after an address change. RS_1 32 bits Output Data read (source 1). RS_2 32 bits Output Data read (source 2). Table 6. Integer Register File signals for write Signal name Width Direction Description RD_ADDR 5 bits Input Destination register address . RD 32 bits Input Data to be written in the destination register. WR_EN 1 bit Input Write enable . When set high, the data placed on RD is written in the destination register at the next clock rising edge. Branch Unit The Branch Unit ( branch_unit.v ) decides if a branch instruction must be taken or not. It receives two operands from the Integer Register File and, based on the value of opcode and funct3 instruction fields, decides the branch. Jump instructions are interpreted as branches that must always be taken. Internally, the unit realizes just two comparisions, deriving other four from them. Table 7 (below) shows the module input and output signals. Table 7. Branch Unit input/output signals Signal name Width Direction Description OPCODE_6_TO_2 5 bits Input Connected to the opcode instruction field. FUNCT3 3 bits Input Connected to the funct3 instruction field. RS1 32 bits Input Connected to the Integer Register File 1st operand source. RS2 32 bits Input Connected to the Integer Register File 2nd operand source. BRANCH_TAKEN 1 bit Output High if the branch must be taken, low otherwise. Load Unit The Load Unit ( load_unit.v ) reads the DATA_IN input signal and forms a 32-bit value based on the load instruction type (encoded in the funct3 field). The formed value (placed on OUTPUT ) can then be written in the Integer Register File. The module input and output signals are shown in table 8. The value of OUTPUT is formed as shown in table 9. Table 8. Load Unit input/output signals Signal name Width Direction Description LOAD_SIZE 2 bits Input Connected to the two least significant bits of the funct3 instruction field. LOAD_UNSIGNED 1 bit Input Connected to the most significant bit of the funct3 instruction field. DATA_IN 32 bits Input 32-bit word read from memory. IADDER_OUT_1_TO_0 2 bits Input Indicates the byte/halfword position in DATA_IN . Used only with load byte/halfword instructions. OUTPUT 32 bits Output 32-bit value to be written in the Integer Register File. Table 9. Load Unit output generation LOAD_SIZE Effect on OUTPUT 2'b00 The byte in the position indicated by IADDER_OUT_1_TO_0 is placed on the least significant byte of OUTPUT . The upper 24 bits are filled according to the LOAD_UNSIGNED signal. 2'b01 The halfword in the position indicated by IADDER_OUT_1_TO_0 is placed on the least significant halfword of OUTPUT . The upper 16 bits are filled according to the LOAD_UNSIGNED signal. 2'b10 All bits of DATA_IN are placed on OUTPUT. 2'b11 All bits of DATA_IN are placed on OUTPUT. LOAD_UNSIGNED Effect on OUTPUT 1'b0 The remaining bits of OUTPUT are filled with the sign bit. 1'b1 The remaining bits of OUTPUT are filled with zeros. Store Unit The Store Unit ( store_unit.v ) drives the signals that interface with memory. It places the data to be written (which can be a byte, halfword or word) in the right position in DATA_OUT and sets the value of WR_MASK in an appropriate way. Table 10 (below) shows the unit input and output signals. Table 10. Store Unit input/output signals Signal name Width Direction Description FUNCT3 3 bits Input Connected to the funct3 instruction field. Indicates the data size (byte, halfword or word). IADDER_OUT 32 bits Input Contains the address (possibly unaligned) where the data must be written. RS2 32 bits Input Connected to Integer Register File source 2. Contains the data to be written (possibly in the wrong position). MEM_WR_REQ 1 bit Input Control signal generated by the Control Unit. When set high indicates a request to write to memory. DATA_OUT 32 bits Output Contains the data to be written in the right position. D_ADDR 32 bits Output Contains the address (aligned) where the data must be written. WR_MASK 4 bits Output A bitmask that indicates which bytes of DATA_OUT must be written. WR_REQ 1 bit Output When set high indicates a request to write to memory. Immediate Generator The Immediate Generator ( imm_generator.v ) rearranges the immediate bits contained in the instruction and, if necessary, sign-extends it to form a 32-bit value. The unit is controlled by the IMM_TYPE signal, generated by the Control Unit. Table 11 shows the unit input and output signals. Table 11. Immediate Generator input/output signals Signal name Width Direction Description INSTR 25 bits Input Connected to the instruction bits (32 to 7). IMM_TYPE 2 bits Input Control signal generated by the Control Unit that indicates the type of immediate that must be generated. IMM 32 bits Output 32-bit generated immediate. CSR Register File The CSR Register File ( csr_file.v ) has the control and status registers required for the implementation of M-mode. Read/write, set and clear operations can be applied to the registers. Table 12 shows the unit input and output signals, except those used for communication with the Machine Control module, which are shown in table 13. Table 12. CSR Register File input/output signals Signal name Width Direction Description WR_EN 1 bit Input Write enable . When set high, updates the CSR addressed by CSR_ADDR at the next clock rising edge according to the operation selected by CSR_OP . CSR_ADDR 12 bits Input Address of the CSR to read/write/modify. CSR_OP 3 bits Input Control signal generated by the Control Unit. Selects the operation to be performed (read/write, set, clear or no operation). CSR_UIMM 5 bits Input Unsigned immediate . Connected to the five least significant bits from the Immediate Generator output. CSR_DATA_IN 32 bits Input In write operations, contains the data to be written. In set or clear operations, contains a bit mask. PC 32 bits Input Program counter value. Used to update the mepc CSR. E_IRQ 1 bit Input External interrupt request . Used to update the MEIP bit of mip CSR. T_IRQ 1 bit Input Timer interrupt request . Used to update the MTIP bit of mip CSR. S_IRQ 1 bit Input Software interrupt request . Used to update the MSIP bit of mip CSR. REAL_TIME 64 bits Input Current value of the real time counter. Used to update the time and timeh CSRs. CSR_DATA_OUT 32 bits Output Contains the data read from the CSR addressed by CSR_ADDR . EPC_OUT 32 bits Output Current value of the mepc CSR. TRAP_ADDRESS 32 bits Output Address of the trap handler first instruction. Table 13. CSR Register File and Machine Control module interface signals Signal name Width Direction Description I_OR_E 1 bit Input Interrupt or exception . When set high indicates an interrupt, otherwise indicates an exception. Used to update the most significant bit of mcause register. CAUSE_IN 4 bits Input Contains the exception code. Used to update the mcause register. SET_CAUSE 1 bit Input When set high updates the mcause register with the values of I_OR_E and CAUSE_IN . SET_EPC 1 bit Input When set high, updates the mepc register with the value of PC. INSTRET_INC 1 bit Input When set high enables the instructions retired counting. MIE_CLEAR 1 bit Input When set high sets the MIE bit of mstatus to zero (which globally disables interrupts). The old value of MIE is saved in the mstatus MPIE field. MIE_SET 1 bit Input When set high sets the MPIE bit of mstatus to one. The old value of MPIE is saved in the mstatus MIE field. MIE 1 bit Output Current value of MIE bit of mstatus CSR. MEIE_OUT 1 bit Output Current value of MEIE bit of mie CSR. MTIE_OUT 1 bit Output Current value of MTIE bit of mie CSR. MSIE_OUT 1 bit Output Current value of MSIE bit of mie CSR. MEIP_OUT 1 bit Output Current value of MEIP bit of mip CSR. MTIP_OUT 1 bit Output Current value of MTIP bit of mip CSR. MSIP_OUT 1 bit Output Current value of MSIP bit of mip CSR. Machine Control The Machine Control module ( machine_control.v ) implements the M-mode, controlling the the program counter generation and updating several CSRs. It has a special communication interface with the CSR Register File, already shown in table 13 (above). Its input and output signals are shown in table 14 (below). Internally, the module implements the finite state machine shown in figure 1 (below). Table 14. Machine Control input/output signals Signal name Width Direction Description ILLEGAL_INSTR 1 bit Input Illegal instruction . When set high indicates that an invalid or not implemented instruction was fetched from memory. MISALIGNED_INSTR 1 bit Input Misaligned instruction . When set high indicates an attempt to fetch an instruction which address is in disagreement with the memory alignment rules. MISALIGNED_LOAD 1 bit Input Misaligned load . When set high indicates an attempt to read data in disagreement with the memory alignment rules. MISALIGNED_STORE 1 bit Input Misaligned store . When set high indicates an attempt to write data to memory in disagreement with the memory alignment rules. OPCODE_6_TO_2 5 bits Input Value of the opcode instruction field. FUNCT3 3 bits Input Value of the funct3 instruction field. FUNCT7 7 bits Input Value of the funct7 instruction field. RS1_ADDR 5 bits Input Value of the rs1 instruction field. RS2_ADDR 5 bits Input Value of the rs2 instruction field. RD_ADDR 5 bits Input Value of the rd instruction field. E_IRQ 1 bit Input External interrupt request . T_IRQ 1 bit Input Timer interrupt request . S_IRQ 1 bit Input Software interrupt request . PC_SRC 2 bit Output Selects the program counter source. FLUSH 1 bit Output Flushes the pipeline when set. TRAP_TAKEN 1 bit Output When set high indicates that a trap will be taken in the next clock cycle. Figure 1. Machine Control finite state machine","title":"Implementation Details"},{"location":"details/#implementation-details","text":"This section contains information on implementation details. It is intended for those who want to know more about how Steel works.","title":"Implementation Details"},{"location":"details/#implemented-csrs","text":"The control and status registers implemented in Steel are shown in table 1, below. The required M-mode registers not shown in the table return the hardwired value predicted by the specifications when read. Table 1. Implemented CSRs CSR Name Address cycle Cycle Counter 0xC00 time System Timer 0xC01 instret Instructions Retired 0xC02 mstatus Machine Status 0x300 misa Machine ISA 0x301 mie Machine Interrupt Enable 0x304 mtvec Machine Trap Vector 0x305 mscratch Machine Scratch 0x340 mepc Machine Exception Program Counter 0x341 mcause Machine Cause 0x342 mtval Machine Trap Value 0x343 mip Machine Interrupt Pending 0x344 mcycle Machine Cycle Counter 0xB00 minstret Machine Instructions Retired 0xB01 mcountinhibit Machine Counter Inhibit 0x320","title":"Implemented CSRs"},{"location":"details/#modules","text":"","title":"Modules"},{"location":"details/#decoder","text":"The Decoder ( decoder.v ) decodes the instruction and generates the signals that control the memory, the Load Unit, the Store Unit, the ALU, the two register files (Integer and CSR), the Immediate Generator and the Writeback Multiplexer. The description of its input and output signals are shown in table 2, below. Table 2. Decoder input/output signals Signal name Width Direction Description OPCODE_6_TO_2 5 bits Input Connected to the instruction opcode field. FUNCT7_5 1 bit Input Connected to the instruction funct7 field. FUNCT3 3 bits Input Connected to the instruction funct3 field. IADDER_OUT_1_TO_0 2 bits Input Used to verify the alignment of loads and stores. TRAP_TAKEN 1 bit Input When set high indicates that a trap will be taken in the next clock cycle. Connected to the Machine Control module. ALU_OPCODE 4 bits Output Selects the operation to be performed by the ALU. MEM_WR_REQ 1 bit Output When set high indicates a request to write to memory. LOAD_SIZE 2 bits Output Indicates the word size of load instruction. LOAD_UNSIGNED 1 bit Output Indicates the type of load instruction (signed or unsigned). ALU_SRC 1 bit Output Selects the ALU 2nd operand. IADDER_SRC 1 bit Output Selects the Immediate Adder 2nd operand. CSR_WR_EN 1 bit Output Controls the WR_EN input of CSR Register File. RF_WR_EN 1 Output Controls the WR_EN input of Integer Register File. WB_MUX_SEL 3 Output Selects the data to be written in the Integer Register File. IMM_TYPE 3 Output Selects the immediate based on the type of the instruction. CSR_OP 3 Output Selects the operation to be performed by the CSR Register File (read/write, set or clear). ILLEGAL_INSTR 1 bit Output When set high indicates that an invalid or not implemented instruction was fetched from memory. MISALIGNED_LOAD 1 bit Output When set high indicates an attempt to read data in disagreement with the memory alignment rules. MISALIGNED_STORE 1 bit Output When set high indicates an attempt to write data to memory in disagreement with the memory alignment rules.","title":"Decoder"},{"location":"details/#alu","text":"The ALU ( alu.v ) applies ten distinct logical and arithmetic operations in parallel to two 32-bit operands, outputting the result selected by OPCODE . The ALU input/output signals and the opcodes are shown in tables 3 and 4, below. The opcode values were assigned to facilitate instruction translation. The most significant bit of OPCODE matches with the second most significant bit in the instruction funct7 field. The remaining three bits match with the instruction funct3 field. Table 3. ALU input/output signals Signal name Width Direction Description OP_1 32 bits Input Operation first operand. OP_2 32 bits Input Operation second operand. OPCODE 4 bits Input Operation code. This signal is driven by funct7 and funct3 instruction fields. RESULT 32 bits Output Result of the requested operation. Table 4. ALU opcodes Opcode Operation Binary value ALU_ADD Addition 4'b0000 ALU_SUB Subtraction 4'b1000 ALU_SLT Set on less than 4'b0010 ALU_SLTU Set on less than unsigned 4'b0011 ALU_AND Bitwise logical AND 4'b0111 ALU_OR Bitwise logical OR 4'b0110 ALU_XOR Bitwise logical XOR 4'b0100 ALU_SLL Logical left shift 4'b0001 ALU_SRL Logical right shift 4'b0101 ALU_SRA Arithmetic right shift 4'b1101","title":"ALU"},{"location":"details/#integer-register-file","text":"The Integer Register File ( integer_file.v ) has 32 general-purpose registers and supports read and write operations. Reads are requested in the pipeline stage 2 and provide data from one or two registers. Writes are requested in the pipeline stage 3 and put the data coming from the Writeback Multiplexer into the selected register. If stage 3 requests to write to a register being read by stage 2, the data to be written is immediately forwarded to stage 2. Each operation is driven by a distinct set of signals, shown in the tables 5 and 6, below. Table 5. Integer Register File signals for read Signal name Width Direction Description RS_1_ADDR 5 bits Input Register source 1 address . The data is placed at RS_1 immediately after an address change. RS_2_ADDR 5 bits Input Register source 2 address . The data is placed at RS_2 immediately after an address change. RS_1 32 bits Output Data read (source 1). RS_2 32 bits Output Data read (source 2). Table 6. Integer Register File signals for write Signal name Width Direction Description RD_ADDR 5 bits Input Destination register address . RD 32 bits Input Data to be written in the destination register. WR_EN 1 bit Input Write enable . When set high, the data placed on RD is written in the destination register at the next clock rising edge.","title":"Integer Register File"},{"location":"details/#branch-unit","text":"The Branch Unit ( branch_unit.v ) decides if a branch instruction must be taken or not. It receives two operands from the Integer Register File and, based on the value of opcode and funct3 instruction fields, decides the branch. Jump instructions are interpreted as branches that must always be taken. Internally, the unit realizes just two comparisions, deriving other four from them. Table 7 (below) shows the module input and output signals. Table 7. Branch Unit input/output signals Signal name Width Direction Description OPCODE_6_TO_2 5 bits Input Connected to the opcode instruction field. FUNCT3 3 bits Input Connected to the funct3 instruction field. RS1 32 bits Input Connected to the Integer Register File 1st operand source. RS2 32 bits Input Connected to the Integer Register File 2nd operand source. BRANCH_TAKEN 1 bit Output High if the branch must be taken, low otherwise.","title":"Branch Unit"},{"location":"details/#load-unit","text":"The Load Unit ( load_unit.v ) reads the DATA_IN input signal and forms a 32-bit value based on the load instruction type (encoded in the funct3 field). The formed value (placed on OUTPUT ) can then be written in the Integer Register File. The module input and output signals are shown in table 8. The value of OUTPUT is formed as shown in table 9. Table 8. Load Unit input/output signals Signal name Width Direction Description LOAD_SIZE 2 bits Input Connected to the two least significant bits of the funct3 instruction field. LOAD_UNSIGNED 1 bit Input Connected to the most significant bit of the funct3 instruction field. DATA_IN 32 bits Input 32-bit word read from memory. IADDER_OUT_1_TO_0 2 bits Input Indicates the byte/halfword position in DATA_IN . Used only with load byte/halfword instructions. OUTPUT 32 bits Output 32-bit value to be written in the Integer Register File. Table 9. Load Unit output generation LOAD_SIZE Effect on OUTPUT 2'b00 The byte in the position indicated by IADDER_OUT_1_TO_0 is placed on the least significant byte of OUTPUT . The upper 24 bits are filled according to the LOAD_UNSIGNED signal. 2'b01 The halfword in the position indicated by IADDER_OUT_1_TO_0 is placed on the least significant halfword of OUTPUT . The upper 16 bits are filled according to the LOAD_UNSIGNED signal. 2'b10 All bits of DATA_IN are placed on OUTPUT. 2'b11 All bits of DATA_IN are placed on OUTPUT. LOAD_UNSIGNED Effect on OUTPUT 1'b0 The remaining bits of OUTPUT are filled with the sign bit. 1'b1 The remaining bits of OUTPUT are filled with zeros.","title":"Load Unit"},{"location":"details/#store-unit","text":"The Store Unit ( store_unit.v ) drives the signals that interface with memory. It places the data to be written (which can be a byte, halfword or word) in the right position in DATA_OUT and sets the value of WR_MASK in an appropriate way. Table 10 (below) shows the unit input and output signals. Table 10. Store Unit input/output signals Signal name Width Direction Description FUNCT3 3 bits Input Connected to the funct3 instruction field. Indicates the data size (byte, halfword or word). IADDER_OUT 32 bits Input Contains the address (possibly unaligned) where the data must be written. RS2 32 bits Input Connected to Integer Register File source 2. Contains the data to be written (possibly in the wrong position). MEM_WR_REQ 1 bit Input Control signal generated by the Control Unit. When set high indicates a request to write to memory. DATA_OUT 32 bits Output Contains the data to be written in the right position. D_ADDR 32 bits Output Contains the address (aligned) where the data must be written. WR_MASK 4 bits Output A bitmask that indicates which bytes of DATA_OUT must be written. WR_REQ 1 bit Output When set high indicates a request to write to memory.","title":"Store Unit"},{"location":"details/#immediate-generator","text":"The Immediate Generator ( imm_generator.v ) rearranges the immediate bits contained in the instruction and, if necessary, sign-extends it to form a 32-bit value. The unit is controlled by the IMM_TYPE signal, generated by the Control Unit. Table 11 shows the unit input and output signals. Table 11. Immediate Generator input/output signals Signal name Width Direction Description INSTR 25 bits Input Connected to the instruction bits (32 to 7). IMM_TYPE 2 bits Input Control signal generated by the Control Unit that indicates the type of immediate that must be generated. IMM 32 bits Output 32-bit generated immediate.","title":"Immediate Generator"},{"location":"details/#csr-register-file","text":"The CSR Register File ( csr_file.v ) has the control and status registers required for the implementation of M-mode. Read/write, set and clear operations can be applied to the registers. Table 12 shows the unit input and output signals, except those used for communication with the Machine Control module, which are shown in table 13. Table 12. CSR Register File input/output signals Signal name Width Direction Description WR_EN 1 bit Input Write enable . When set high, updates the CSR addressed by CSR_ADDR at the next clock rising edge according to the operation selected by CSR_OP . CSR_ADDR 12 bits Input Address of the CSR to read/write/modify. CSR_OP 3 bits Input Control signal generated by the Control Unit. Selects the operation to be performed (read/write, set, clear or no operation). CSR_UIMM 5 bits Input Unsigned immediate . Connected to the five least significant bits from the Immediate Generator output. CSR_DATA_IN 32 bits Input In write operations, contains the data to be written. In set or clear operations, contains a bit mask. PC 32 bits Input Program counter value. Used to update the mepc CSR. E_IRQ 1 bit Input External interrupt request . Used to update the MEIP bit of mip CSR. T_IRQ 1 bit Input Timer interrupt request . Used to update the MTIP bit of mip CSR. S_IRQ 1 bit Input Software interrupt request . Used to update the MSIP bit of mip CSR. REAL_TIME 64 bits Input Current value of the real time counter. Used to update the time and timeh CSRs. CSR_DATA_OUT 32 bits Output Contains the data read from the CSR addressed by CSR_ADDR . EPC_OUT 32 bits Output Current value of the mepc CSR. TRAP_ADDRESS 32 bits Output Address of the trap handler first instruction. Table 13. CSR Register File and Machine Control module interface signals Signal name Width Direction Description I_OR_E 1 bit Input Interrupt or exception . When set high indicates an interrupt, otherwise indicates an exception. Used to update the most significant bit of mcause register. CAUSE_IN 4 bits Input Contains the exception code. Used to update the mcause register. SET_CAUSE 1 bit Input When set high updates the mcause register with the values of I_OR_E and CAUSE_IN . SET_EPC 1 bit Input When set high, updates the mepc register with the value of PC. INSTRET_INC 1 bit Input When set high enables the instructions retired counting. MIE_CLEAR 1 bit Input When set high sets the MIE bit of mstatus to zero (which globally disables interrupts). The old value of MIE is saved in the mstatus MPIE field. MIE_SET 1 bit Input When set high sets the MPIE bit of mstatus to one. The old value of MPIE is saved in the mstatus MIE field. MIE 1 bit Output Current value of MIE bit of mstatus CSR. MEIE_OUT 1 bit Output Current value of MEIE bit of mie CSR. MTIE_OUT 1 bit Output Current value of MTIE bit of mie CSR. MSIE_OUT 1 bit Output Current value of MSIE bit of mie CSR. MEIP_OUT 1 bit Output Current value of MEIP bit of mip CSR. MTIP_OUT 1 bit Output Current value of MTIP bit of mip CSR. MSIP_OUT 1 bit Output Current value of MSIP bit of mip CSR.","title":"CSR Register File"},{"location":"details/#machine-control","text":"The Machine Control module ( machine_control.v ) implements the M-mode, controlling the the program counter generation and updating several CSRs. It has a special communication interface with the CSR Register File, already shown in table 13 (above). Its input and output signals are shown in table 14 (below). Internally, the module implements the finite state machine shown in figure 1 (below). Table 14. Machine Control input/output signals Signal name Width Direction Description ILLEGAL_INSTR 1 bit Input Illegal instruction . When set high indicates that an invalid or not implemented instruction was fetched from memory. MISALIGNED_INSTR 1 bit Input Misaligned instruction . When set high indicates an attempt to fetch an instruction which address is in disagreement with the memory alignment rules. MISALIGNED_LOAD 1 bit Input Misaligned load . When set high indicates an attempt to read data in disagreement with the memory alignment rules. MISALIGNED_STORE 1 bit Input Misaligned store . When set high indicates an attempt to write data to memory in disagreement with the memory alignment rules. OPCODE_6_TO_2 5 bits Input Value of the opcode instruction field. FUNCT3 3 bits Input Value of the funct3 instruction field. FUNCT7 7 bits Input Value of the funct7 instruction field. RS1_ADDR 5 bits Input Value of the rs1 instruction field. RS2_ADDR 5 bits Input Value of the rs2 instruction field. RD_ADDR 5 bits Input Value of the rd instruction field. E_IRQ 1 bit Input External interrupt request . T_IRQ 1 bit Input Timer interrupt request . S_IRQ 1 bit Input Software interrupt request . PC_SRC 2 bit Output Selects the program counter source. FLUSH 1 bit Output Flushes the pipeline when set. TRAP_TAKEN 1 bit Output When set high indicates that a trap will be taken in the next clock cycle. Figure 1. Machine Control finite state machine","title":"Machine Control"},{"location":"getting/","text":"Getting Started What you need to know first Steel must be connected to a word-addressed memory with read/write latency of 1 clock cycle. The interfaces to fetch instructions and to read/write data were designed to facilitate the integration with FPGA Block RAMs and memory arrays. If you don't need hardware timers, you must connect the REAL_TIME bus to a hardwired value. Otherwise, you must connect it to a real-time counter. The E_IRQ , T_IRQ , and S_IRQ signals (used to request for interrupts) can be connected to a single device or to an interrupt controller that manages interrupts from multiple devices. If interrupts are not needed, these signals must be connected to zero. Using Steel in your project To use Steel in your project you must import all files from the rtl directory to it. Then instantiate Steel using the following template: steel_top core( .CLK( ), .RESET( ), .REAL_TIME( ), .I_ADDR( ), .INSTR( ), .D_ADDR( ), .DATA_OUT( ), .WR_REQ( ), .WR_MASK( ), .DATA_IN( ), .E_IRQ( ), .T_IRQ( ), .S_IRQ( ) ); Read the section Input and Output Signals for more information on the signals above. Writing software for Steel You can write and compile software for Steel using RISC-V GNU Toolchain . Follow the instructions in its README.md file for installing the Newlib cross-compiler. You must use the following options to configure the installation: ./configure --prefix=/opt/riscv --with-arch=rv32i --with-abi=ilp32 make The util folder has a script ( mengen.sh ) that compiles a C file (*.c) and turns the generated program into a .mem file, which can be read by the Verilog $readmemh system task and then used to initialize a RAM memory array. This script requires riscv32-unknown-elf-gcc , riscv32-unknown-elf-objdump (provided by RISC-V GNU Toolchain) and riscv32-unknown-elf-elf2hex (which can be found here ). Example system The figure below shows an example of how Steel can be used as processing unit in embedded systems projects. The same architecture can be used to build other systems. The example is composed of an 8KB RAM memory array ( ram.v ), a memory mapped UART transmitter ( uart_tx.v , 9600 baud rate, 1 stop bit, no parity and no control), a bus arbiter ( bus_arbiter.v ) and, of course, the Steel Core. The address 0x00010000 is used to access the UART transmitter. RAM addresses start at 0x00000000 and end at 0x00001fff. All other addresses are invalid. A bus arbiter is used to multiplex the data read/write signals according to the address the core wants to access. The timer and interrupt signals are hardwired to zero because neither timers nor interrupts are used in this system. To work properly, the system must be connected to a 100MHz clock source. The implementation files of this system can be found in the soc directory. The vivado directory has the project and implementation of this system for an Artix-7 FPGA (Digilent Nexys-4 board) built with Vivado. The util directory has an example program ( hello.c ) for it, which can be compiled using the memgen.sh script (see the section above). The program sends the string \"Hello World, Steel!\" through the UART transmitter, which is printed on the screen if the UART is connected to a terminal. The code below shows how to send data through the UART transmitter in a C program: char* UART_ADDRESS = (char*) 0x00010000; // the UART address while( (*UART_ADDRESS) != 1 ); // waits UART transmitter to be ready (*UART_ADDRESS) = 'c'; // send a single character to UART transmitter Or alternatively in RISC-V assembly: lui t0, 0x10 // loads in t0 the UART address readyloop: li t1, 1 lw t2, 0(t0); bne t2, t1, readyloop; // checks if the UART is ready li t3, 0x63; // loads in t3 the character 'c' sbu t3, 0(t0); // send the character to UART","title":"Getting Started"},{"location":"getting/#getting-started","text":"","title":"Getting Started"},{"location":"getting/#what-you-need-to-know-first","text":"Steel must be connected to a word-addressed memory with read/write latency of 1 clock cycle. The interfaces to fetch instructions and to read/write data were designed to facilitate the integration with FPGA Block RAMs and memory arrays. If you don't need hardware timers, you must connect the REAL_TIME bus to a hardwired value. Otherwise, you must connect it to a real-time counter. The E_IRQ , T_IRQ , and S_IRQ signals (used to request for interrupts) can be connected to a single device or to an interrupt controller that manages interrupts from multiple devices. If interrupts are not needed, these signals must be connected to zero.","title":"What you need to know first"},{"location":"getting/#using-steel-in-your-project","text":"To use Steel in your project you must import all files from the rtl directory to it. Then instantiate Steel using the following template: steel_top core( .CLK( ), .RESET( ), .REAL_TIME( ), .I_ADDR( ), .INSTR( ), .D_ADDR( ), .DATA_OUT( ), .WR_REQ( ), .WR_MASK( ), .DATA_IN( ), .E_IRQ( ), .T_IRQ( ), .S_IRQ( ) ); Read the section Input and Output Signals for more information on the signals above.","title":"Using Steel in your project"},{"location":"getting/#writing-software-for-steel","text":"You can write and compile software for Steel using RISC-V GNU Toolchain . Follow the instructions in its README.md file for installing the Newlib cross-compiler. You must use the following options to configure the installation: ./configure --prefix=/opt/riscv --with-arch=rv32i --with-abi=ilp32 make The util folder has a script ( mengen.sh ) that compiles a C file (*.c) and turns the generated program into a .mem file, which can be read by the Verilog $readmemh system task and then used to initialize a RAM memory array. This script requires riscv32-unknown-elf-gcc , riscv32-unknown-elf-objdump (provided by RISC-V GNU Toolchain) and riscv32-unknown-elf-elf2hex (which can be found here ).","title":"Writing software for Steel"},{"location":"getting/#example-system","text":"The figure below shows an example of how Steel can be used as processing unit in embedded systems projects. The same architecture can be used to build other systems. The example is composed of an 8KB RAM memory array ( ram.v ), a memory mapped UART transmitter ( uart_tx.v , 9600 baud rate, 1 stop bit, no parity and no control), a bus arbiter ( bus_arbiter.v ) and, of course, the Steel Core. The address 0x00010000 is used to access the UART transmitter. RAM addresses start at 0x00000000 and end at 0x00001fff. All other addresses are invalid. A bus arbiter is used to multiplex the data read/write signals according to the address the core wants to access. The timer and interrupt signals are hardwired to zero because neither timers nor interrupts are used in this system. To work properly, the system must be connected to a 100MHz clock source. The implementation files of this system can be found in the soc directory. The vivado directory has the project and implementation of this system for an Artix-7 FPGA (Digilent Nexys-4 board) built with Vivado. The util directory has an example program ( hello.c ) for it, which can be compiled using the memgen.sh script (see the section above). The program sends the string \"Hello World, Steel!\" through the UART transmitter, which is printed on the screen if the UART is connected to a terminal. The code below shows how to send data through the UART transmitter in a C program: char* UART_ADDRESS = (char*) 0x00010000; // the UART address while( (*UART_ADDRESS) != 1 ); // waits UART transmitter to be ready (*UART_ADDRESS) = 'c'; // send a single character to UART transmitter Or alternatively in RISC-V assembly: lui t0, 0x10 // loads in t0 the UART address readyloop: li t1, 1 lw t2, 0(t0); bne t2, t1, readyloop; // checks if the UART is ready li t3, 0x63; // loads in t3 the character 'c' sbu t3, 0(t0); // send the character to UART","title":"Example system"},{"location":"steelio/","text":"Input and Output Signals The figure below shows Steel input and output signals (except CLK and RESET ). The following sections explain their functions in detail. The interfaces to fetch instructions and to read/write data can be connected to any type of memory, but were designed to facilitate integration with FPGAs Block RAMs and memory arrays. Interrupt controller interface The interrupt controller interface has three signals used to request external, timer and software interrupts, shown in the table below. The interrupt request process is explained in the sections Exceptions and Interrupts and Interrupt Request . Signal Width Direction Description E_IRQ 1 bit Input When set high indicates an external interrupt request. T_IRQ 1 bit Input When set high indicates a timer interrupt request. S_IRQ 1 bit Input When set high indicates a software interrupt request. Instruction fetch interface The instruction fetch interface has two signals used in the instruction fetch process, shown in the table below. The process of fetching instructions is explained in the section Instruction Fetch . Signal Width Direction Description INSTR 32 bits Input Contains the instruction fetched from memory. I_ADDR 32 bits Output Contains the address of the instruction the core wants to fetch from memory. Data read/write interface The data read/write interface has five signals used in the process of reading/writing data from/to memory. The signals are shown in the table below. The process of fetching data from memory is explained in the section Data Fetch . The process of writing data is explained in the section Data Writing . Signal Width Direction Description DATA_IN 32 bits Input Contains the data fetched from memory. D_ADDR 32 bits Output In a write operation, contains the address of the memory position where the data will be stored. In a read operation, contains the address of the memory position where the data to be fetched is. The address is always aligned on a four byte boundary (the last two bits are always zero). DATA_OUT 32 bits Output Contains the data to be stored in memory. Used only with write operations. WR_REQ 1 bit Output When high, indicates a request to write data. Used only with write operations. WR_MASK 4 bits Output Contains a mask of four byte-write enable bits. A bit high indicates that the corresponding byte must be written. Used only with write operations. Real-time counter interface The real time counter interface has just one signal used to update the time CSR, shown in the table below. The process of updating the time register is explained in the section Time CSR update . Signal Width Direction Description REAL_TIME 64 bits Input Contains the current value read from a real time counter. CLK and RESET signals The core also has the CLK and RESET input signals, which are not shown in the figure above. The CLK signal must be connected to a clock source. The RESET signal is active high and resets the core synchronously.","title":"Input and Output Signals"},{"location":"steelio/#input-and-output-signals","text":"The figure below shows Steel input and output signals (except CLK and RESET ). The following sections explain their functions in detail. The interfaces to fetch instructions and to read/write data can be connected to any type of memory, but were designed to facilitate integration with FPGAs Block RAMs and memory arrays.","title":"Input and Output Signals"},{"location":"steelio/#interrupt-controller-interface","text":"The interrupt controller interface has three signals used to request external, timer and software interrupts, shown in the table below. The interrupt request process is explained in the sections Exceptions and Interrupts and Interrupt Request . Signal Width Direction Description E_IRQ 1 bit Input When set high indicates an external interrupt request. T_IRQ 1 bit Input When set high indicates a timer interrupt request. S_IRQ 1 bit Input When set high indicates a software interrupt request.","title":"Interrupt controller interface"},{"location":"steelio/#instruction-fetch-interface","text":"The instruction fetch interface has two signals used in the instruction fetch process, shown in the table below. The process of fetching instructions is explained in the section Instruction Fetch . Signal Width Direction Description INSTR 32 bits Input Contains the instruction fetched from memory. I_ADDR 32 bits Output Contains the address of the instruction the core wants to fetch from memory.","title":"Instruction fetch interface"},{"location":"steelio/#data-readwrite-interface","text":"The data read/write interface has five signals used in the process of reading/writing data from/to memory. The signals are shown in the table below. The process of fetching data from memory is explained in the section Data Fetch . The process of writing data is explained in the section Data Writing . Signal Width Direction Description DATA_IN 32 bits Input Contains the data fetched from memory. D_ADDR 32 bits Output In a write operation, contains the address of the memory position where the data will be stored. In a read operation, contains the address of the memory position where the data to be fetched is. The address is always aligned on a four byte boundary (the last two bits are always zero). DATA_OUT 32 bits Output Contains the data to be stored in memory. Used only with write operations. WR_REQ 1 bit Output When high, indicates a request to write data. Used only with write operations. WR_MASK 4 bits Output Contains a mask of four byte-write enable bits. A bit high indicates that the corresponding byte must be written. Used only with write operations.","title":"Data read/write interface"},{"location":"steelio/#real-time-counter-interface","text":"The real time counter interface has just one signal used to update the time CSR, shown in the table below. The process of updating the time register is explained in the section Time CSR update . Signal Width Direction Description REAL_TIME 64 bits Input Contains the current value read from a real time counter.","title":"Real-time counter interface"},{"location":"steelio/#clk-and-reset-signals","text":"The core also has the CLK and RESET input signals, which are not shown in the figure above. The CLK signal must be connected to a clock source. The RESET signal is active high and resets the core synchronously.","title":"CLK and RESET signals"},{"location":"timing/","text":"Timing Diagrams Instruction fetch To fetch an instruction, the core places the instruction address on I_ADDR . The memory must place the instruction on INSTR at the next clock rising edge. The figure below shows the timing diagram of this process. In the figure, mem[addrX] denotes the instruction stored at the memory position addrX . Data fetch To fetch data from memory, the core puts the data address on D_ADDR . The memory must place the data on DATA_IN at the next clock rising edge. The figure below shows the timing diagram of this process. In the figure, mem[addrX] denotes the data stored at the memory position addrX . Data writing To write data to memory, the core drives D_ADDR , DATA_OUT , WR_REQ and WR_MASK signals as follows: D_ADDR receives the address of the memory position where the data must be written; DATA_OUT receives the data to be written; WR_REQ is set high; WR_MASK receives a byte-write enable mask that indicates which bytes of DATA_OUT must be written. The memory must perform the write operation at the next clock rising edge. The core can request to write bytes, halfwords and words. The figure below shows the process of writing data to memory. DATA_IN is not used in the process and appears only to show the memory contents after writing. The figure shows five clock cycles, in which the core requests to write in the second, third and fourth cycles. In the second clock cycle, the core requests to write the word 0x12345678 at the address addr2 . In the third, requests to write the halfword 0xABCD at the upper half of addr2 , and in the fourth requests to write the byte 0xEF at the second least significant byte of addr2 . The value stored at addr2 after each of these operations appears on DATA_IN and are highlighted in blue. Interrupt request An external device (or an interrupt controller managing several devices) can request interrupts by setting high the appropriate IRQ signal, which is E_IRQ for external interrupts, T_IRQ for timer interrupts and S_IRQ for software interrupts. The IRQ signal of the requested interrupt must be set high for one clock cycle and set low for the next. The figure below shows the timing diagram of the interrupt request process. Since the process is the same for all types of interrupt, X_IRQ is used to denote E_IRQ , T_IRQ or S_IRQ . TRAP_ADDR denotes the address of the trap handler first instruction. time CSR update When connected to a real-time counter, the core updates the time CSR with the value placed on REAL_TIME at each clock rising edge, as shown in the figure below. timeX denotes arbitrary time values.","title":"Timing Diagrams"},{"location":"timing/#timing-diagrams","text":"","title":"Timing Diagrams"},{"location":"timing/#instruction-fetch","text":"To fetch an instruction, the core places the instruction address on I_ADDR . The memory must place the instruction on INSTR at the next clock rising edge. The figure below shows the timing diagram of this process. In the figure, mem[addrX] denotes the instruction stored at the memory position addrX .","title":"Instruction fetch"},{"location":"timing/#data-fetch","text":"To fetch data from memory, the core puts the data address on D_ADDR . The memory must place the data on DATA_IN at the next clock rising edge. The figure below shows the timing diagram of this process. In the figure, mem[addrX] denotes the data stored at the memory position addrX .","title":"Data fetch"},{"location":"timing/#data-writing","text":"To write data to memory, the core drives D_ADDR , DATA_OUT , WR_REQ and WR_MASK signals as follows: D_ADDR receives the address of the memory position where the data must be written; DATA_OUT receives the data to be written; WR_REQ is set high; WR_MASK receives a byte-write enable mask that indicates which bytes of DATA_OUT must be written. The memory must perform the write operation at the next clock rising edge. The core can request to write bytes, halfwords and words. The figure below shows the process of writing data to memory. DATA_IN is not used in the process and appears only to show the memory contents after writing. The figure shows five clock cycles, in which the core requests to write in the second, third and fourth cycles. In the second clock cycle, the core requests to write the word 0x12345678 at the address addr2 . In the third, requests to write the halfword 0xABCD at the upper half of addr2 , and in the fourth requests to write the byte 0xEF at the second least significant byte of addr2 . The value stored at addr2 after each of these operations appears on DATA_IN and are highlighted in blue.","title":"Data writing"},{"location":"timing/#interrupt-request","text":"An external device (or an interrupt controller managing several devices) can request interrupts by setting high the appropriate IRQ signal, which is E_IRQ for external interrupts, T_IRQ for timer interrupts and S_IRQ for software interrupts. The IRQ signal of the requested interrupt must be set high for one clock cycle and set low for the next. The figure below shows the timing diagram of the interrupt request process. Since the process is the same for all types of interrupt, X_IRQ is used to denote E_IRQ , T_IRQ or S_IRQ . TRAP_ADDR denotes the address of the trap handler first instruction.","title":"Interrupt request"},{"location":"timing/#time-csr-update","text":"When connected to a real-time counter, the core updates the time CSR with the value placed on REAL_TIME at each clock rising edge, as shown in the figure below. timeX denotes arbitrary time values.","title":"time CSR update"},{"location":"traps/","text":"Exceptions and Interrupts Supported exceptions and interrupts Steel supports the exceptions and interrupts shown in the table below. They are listed in descending priority order (the highest priority is at the top of the table). If two or more exceptions/interrupts occur at the same time, the one with the highest priority is taken. Exceptions always cause a trap to be taken. An interrupt will cause a trap only if enabled. Each type of interrupt has an interrupt-enable bit in the mie register. Interrupts are globally enable/disabled by setting the MIE bit of mstatus register. Exception / Interrupt mcause interrupt bit mcause exception code Machine external interrupt 1 11 Machine software interrupt 1 3 Machine timer interrupt 1 7 Illegal instruction exception 0 2 Instruction address-misaligned exception 0 0 Environment call from M-mode exception 0 11 Environment break exception 0 3 Store address-misaligned exception 0 6 Load address-misaligned exception 0 4 Trap handling in Steel Exceptions and interrupts are handled by a trap handler routine stored in memory (your software must provide one). The address of the trap handler first instruction is configured using the mtvec register. Steel supports both direct and vectorized interrupt modes. More information on interrupt modes and configuration of the mtvec register can be found in RISC-V specifications . When a trap is taken, the core proceeds as follows: the address of the interrupted instruction (or the instruction that encountered the exception) is saved in the mepc register; the value of the mtval register is set to: the misaligned address that caused the exception for all types of address-misaligned exceptions, or zero otherwise; the value of the mstatus MIE bit is saved in the MPIE field and then set to zero; the program counter is set to the address of the trap handler first instruction. The mret instruction is used to return from traps. When executed, the core proceeds as follows: the value of the mstatus MPIE bit is saved in the MIE field and then set to one; the program counter is set to the value of mepc register. Nested interrupts capability The core globally disables new interrupts when takes into a trap. The trap handler can re-enable interrupts by setting the mstatus MIE bit to one, thus enabling nested interrupts. To return from nested traps, the trap handler must stack and manage the values of the mepc register in memory.","title":"Exceptions and Interrupts"},{"location":"traps/#exceptions-and-interrupts","text":"","title":"Exceptions and Interrupts"},{"location":"traps/#supported-exceptions-and-interrupts","text":"Steel supports the exceptions and interrupts shown in the table below. They are listed in descending priority order (the highest priority is at the top of the table). If two or more exceptions/interrupts occur at the same time, the one with the highest priority is taken. Exceptions always cause a trap to be taken. An interrupt will cause a trap only if enabled. Each type of interrupt has an interrupt-enable bit in the mie register. Interrupts are globally enable/disabled by setting the MIE bit of mstatus register. Exception / Interrupt mcause interrupt bit mcause exception code Machine external interrupt 1 11 Machine software interrupt 1 3 Machine timer interrupt 1 7 Illegal instruction exception 0 2 Instruction address-misaligned exception 0 0 Environment call from M-mode exception 0 11 Environment break exception 0 3 Store address-misaligned exception 0 6 Load address-misaligned exception 0 4","title":"Supported exceptions and interrupts"},{"location":"traps/#trap-handling-in-steel","text":"Exceptions and interrupts are handled by a trap handler routine stored in memory (your software must provide one). The address of the trap handler first instruction is configured using the mtvec register. Steel supports both direct and vectorized interrupt modes. More information on interrupt modes and configuration of the mtvec register can be found in RISC-V specifications . When a trap is taken, the core proceeds as follows: the address of the interrupted instruction (or the instruction that encountered the exception) is saved in the mepc register; the value of the mtval register is set to: the misaligned address that caused the exception for all types of address-misaligned exceptions, or zero otherwise; the value of the mstatus MIE bit is saved in the MPIE field and then set to zero; the program counter is set to the address of the trap handler first instruction. The mret instruction is used to return from traps. When executed, the core proceeds as follows: the value of the mstatus MPIE bit is saved in the MIE field and then set to one; the program counter is set to the value of mepc register.","title":"Trap handling in Steel"},{"location":"traps/#nested-interrupts-capability","text":"The core globally disables new interrupts when takes into a trap. The trap handler can re-enable interrupts by setting the mstatus MIE bit to one, thus enabling nested interrupts. To return from nested traps, the trap handler must stack and manage the values of the mepc register in memory.","title":"Nested interrupts capability"},{"location":"uarch/","text":"Microarchitecture Steel has 3 pipeline stages, a single execution thread and issues only one instruction per clock cycle. Therefore, all instructions are executed in program order. Fig. 1 (below) shows the Steel microarchitecture in register-transfer level (RTL). Circles and trapezoids represent combinational logic units. Rectangles represent sequential logic units. Implementation details can be found in the section Implementation Details . Fig. 1: Steel Core microarchitecture Fig. 2 (below) shows the tasks performed by each pipeline stage. In the first stage, the core generates the program counter and fetches the instruction from memory. In the second, the instruction is decoded and the control signals for all units are generated. Branches, jumps and stores are executed in advance in this stage, which also generates the immediates and fetches the data from memory for load instructions. The last stage executes all other instructions and writes back the results in the register file. Fig. 2: Steel Core pipeline overview","title":"Microarchitecture"},{"location":"uarch/#microarchitecture","text":"Steel has 3 pipeline stages, a single execution thread and issues only one instruction per clock cycle. Therefore, all instructions are executed in program order. Fig. 1 (below) shows the Steel microarchitecture in register-transfer level (RTL). Circles and trapezoids represent combinational logic units. Rectangles represent sequential logic units. Implementation details can be found in the section Implementation Details . Fig. 1: Steel Core microarchitecture Fig. 2 (below) shows the tasks performed by each pipeline stage. In the first stage, the core generates the program counter and fetches the instruction from memory. In the second, the instruction is decoded and the control signals for all units are generated. Branches, jumps and stores are executed in advance in this stage, which also generates the immediates and fetches the data from memory for load instructions. The last stage executes all other instructions and writes back the results in the register file. Fig. 2: Steel Core pipeline overview","title":"Microarchitecture"}]}